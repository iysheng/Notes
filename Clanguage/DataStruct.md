
### libevent 代码阅读笔记
1. 数据结构 tailqueue
2. 数据结构 list
3. gnu gcc 的 attribute 属性，标记函数属性的时候，添加到函数的最开始，结构体的最末尾！！！
``` C
/*
 * __attribute__ ((unused)) 属性标记这个函数极有可能不会调用，告诉 gcc 不要打警告
 */
__attribute__ ((unused)) int funca(void)
{
    return 0;
}

/*
 * __attribute__((packed)) 属性标记这个结构体具有打包属性，纵使这个结构体没有实际的 pack 效果，也不要打警告
 */
struct foo {
int x;
char a, b, c, d;
} __attribute__((packed));
```
4. inline 关键字修改函数定义
```C
inline void func(void)
{

}
```
5. (void)x; /* 可以避免编译器的警告未使用的变量 */
6. #pragma pack(n) 可以修改 alignment

### tmux 代码阅读笔记
1.int flock(int fd, int operation);

### Misc 库函数或者系统调用 memo 记录
1. ftruncate 裁剪文件时，文件的位置偏移并不会发生变化，所以执行完 ftruncate 函数后或者前需要手动修改下文件的偏移 lseek


### 数据结构
1. 二分查找（必须是有序排列）
2. 树，除了跟结点之外，其他结点的父结点只有一个，一颗 N 个结点的树有 N - 1 条边
	1. 结点的度（degree）：结点的子树的个数
	2. 树的度：树的所有结点中最大的度数
	3. 叶结点：度为 0  的结点
	4. 父结点：有子树的结点是其子树的父结点
	5. 子结点：
	6. 兄弟结点（sibling）：
	7. 路径和路径长度：路径包含边的个数
	8. 祖先结点（ancestor）：
	9. 子孙结点（descendant）：
	10. 结点的层次（level）：根结点在 1 层，其他任一结点的层数是其父结点层数加 1
	11. 树的深度（depth）：树中所有结点中最大层次的树深度

### 操作符优先级
|级别（由高到低）|操作符（使用空格分隔）|结合性|
|---|:---|:---|
|1|() [] -> .|由左向右|
|2|++ -- + - ! ~ (type) * & sizeof|由右向左|
|3|* / %|由左向右|
|4|+ -|由左向右|
|5|<< >>|由左向右|
|6|< <= > >=|由左向右|
|7|== !=|由左向右|
|8|&|由左向右|
|9|^|由左向右|
|10|\||由左向右|
|11|&&|由左向右|
|12|\|\||由左向右|
|13|?:|由右向左|
|14|= += -= *= /= %= &= ^= \|= <<= >>=|由右向左|
|15|,|由左向右|

### gcc 汇编部分内容
* .size 指令
	* .size name, expression // 设置 name 这个符号的大小,这个指令一般用来设置函数符号大小
* .syntax unified // 可以同时使用 arm 和 thumb 指令集???

### [hello-algo](https://github.com/krahets/hello-algo) 阅读笔记

#### 计算复杂度(算法运行追求,运行的快,内存占用小)

* 时间效率:时间复杂度(Time Complexity),算法运行速度快慢,时间复杂度分析采取了不同的做法,统计的不是算法运行时间,而是算法运行时间随着数据量变大时的**增长趋势**.

  * 常数阶:算法运行时间不随着输入数据的增长而增大
  * 线性阶:算法运行时间随着输入数据的增大而线性增大
  
* 在计算时间复杂度时,有如下偷懒技巧:
  1. 跳过数量和 n 无关的操作

  2. 省略所有系数
  
  3. 循环嵌套时使用乘法,总操作数量是外层循环和内存循环的积,每层循环仍然使用1和2技巧
  
  ```c++
  void algorithm(int n) {
    int a = 1;  // +0（技巧 1）
    a = a + n;  // +0（技巧 1）
    // +n（技巧 2）
    for (int i = 0; i < 5 * n + 1; i++) {
        cout << 0 << endl;
    }
    // +n*n（技巧 3）
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < n + 1; j++) {
            cout << 0 << endl;
        }
    }
	}
  // 结论:上述算法的复杂度是 O(n*n),即平方阶
  ```
  
* 空间效率:空间复杂度(Space Complexity),占用的内存空间大小,可以分为如下几种类型:

  * 输入空间:存储算法的输入数据
  * 暂存空间:存储算法的变量,对象,函数上下文等数据
    * 暂存数据,保存算法运行中的各种常量,变量和对象
    * 栈帧空间,保存调用函数的上下文数据
    * 指令空间,保存编译后的程序指令,在实际统计中一般忽略不记
  * 输出空间:存储算法的输出数据
  
  实际测试复杂度时存在一定的局限性,一般采用估算的方法.通常情况下,空间复杂度的计算范围是:暂存空间和输出空间.并且,空间复杂度,一般只关注"最差空间复杂度"
  
* 物理结构主要有两种:连续的数组和离散的链表.所有数据结构都是由数组或链表,或者兼而有之.
* 
